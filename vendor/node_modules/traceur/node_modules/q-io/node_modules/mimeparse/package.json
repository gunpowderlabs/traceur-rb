{
  "name": "mimeparse",
  "version": "0.1.4",
  "description": "Basic functions for handling mime-types.",
  "homepage": "http://github.com/kriskowal/mimeparse/",
  "contributors": [
    {
      "name": "Joe Gregario"
    },
    {
      "name": "J. Chris Anderson",
      "email": "jchris@apache.org"
    },
    {
      "name": "Kris Kowal",
      "email": "kris@cixar.com",
      "url": "http://github.com/kriskowal/"
    },
    {
      "name": "Ivan Zuzak",
      "email": "izuzak@gmail.com",
      "url": "http://ivanzuzak.info"
    }
  ],
  "bugs": {
    "url": "http://github.com/kriskowal/mimeparse/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/kriskowal/mimeparse/raw/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/kriskowal/mimeparse.git"
  },
  "main": "lib/mimeparse.js",
  "readme": "\n\nThis module provides basic functions for handling mime-types. It can\nhandle matching mime-types against a list of media-ranges. See section\n14.1 of the HTTP specification [RFC 2616] for a complete explanation.\n\n  <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1>\n\nA port to JavaScript of Joe Gregorio's MIME-Type Parser:\n\n  <http://code.google.com/p/mimeparse/>\n\nPorted by J. Chris Anderson <jchris@apache.org>, targeting the\nSpidermonkey runtime.\n\nPorted to Chiron, Narwhal, Node by Kris Kowal.\n\n  <http://github.com/kriskowal/mimeparse>\n\n\nInstallation\n============\n\n    Install <http://github.com/isaacs/npm>\n\n    npm install mimeparse\n\n\nThe API\n=======\n\nparseMimeType(mimeType)\n\n    Carves up a mime-type and returns an Array of the\n    [type, subtype, params] where \"params\" is a Hash of all\n    the parameters for the media range.\n\n    For example, the media range \"application/xhtml;q=0.5\" would\n    get parsed into::\n\n        [\"application\", \"xhtml\", { \"q\" : \"0.5\" }]\n\nparseMediaRange(range)\n\n    Carves up a media range and returns an Array of the\n    [type, subtype, params] where \"params\" is a Object with\n    all the parameters for the media range.\n    \n    For example, the media range \"application/*;q=0.5\" would\n    get parsed into::\n    \n        [\"application\", \"*\", { \"q\" : \"0.5\" }]\n    \n    In addition this function also guarantees that there\n    is a value for \"q\" in the params dictionary, filling it\n    in with a proper default if necessary.\n\nfitnessAndQualityParsed(mimeType, parsedRanges)\n\n    Find the best match for a given mime-type against\n    a list of media_ranges that have already been\n    parsed by parseMediaRange(). Returns an array of\n    the fitness value and the value of the 'q' quality\n    parameter of the best match, or (-1, 0) if no match\n    was found. Just as for qualityParsed(), 'parsed_ranges'\n    must be a list of parsed media ranges.\n\nqualityParsed(mimeType, parsedRanges)\n\n    Find the best match for a given mime-type against\n    a list of media_ranges that have already been\n    parsed by parseMediaRange(). Returns the\n    'q' quality parameter of the best match, 0 if no\n    match was found. This function bahaves the same as quality()\n    except that 'parsedRanges' must be a list of\n    parsed media ranges.\n\nquality(mimeType, ranges)\n\n    Returns the quality 'q' of a mime-type when compared\n    against the media-ranges in ranges. For example::\n\n        >>> quality('text/html','text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, *\\/*;q=0.5')\n        0.7\n\nbestMatch(supported, header)\n\n    Takes a list of supported mime-types and finds the best\n    match for all the media-ranges listed in header. The value of\n    header must be a string that conforms to the format of the\n    HTTP Accept: header. The value of 'supported' is a list of\n    mime-types::\n    \n        >>> bestMatch(['application/xbel+xml', 'text/xml'], 'text/*;q=0.5,*\\/*; q=0.1')\n        'text/xml'\n\n",
  "readmeFilename": "README",
  "_id": "mimeparse@0.1.4",
  "_from": "mimeparse@~0.1.4"
}
